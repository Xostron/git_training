# Список задач Leetcode

Two sum problem (Задача о двух суммах)
Sorting arrays (Сортировка массивов)
Largest common subsequences (Наибольшие общие последовательности)
Valid parentheses (Правильные скобки)
Search 2D matrix (Поиск двумерной матрицы)
Valid anagrams (Подходящие анаграммы)
Binary Search Tree (BST) (Двоичное дерево поиска)
Level order traversal (Обход по уровням)
Linked lists (Связные списки)
Longest substring without repeating characters (Самая длинная подстрока без повторяющихся символов)
Valid palindromes (Истинные палиндромы)
Path sum (Сумма путей)

# Шаблоны алгоритмов

https://wiki.merionet.ru/articles/7-vazneisix-sablonov-s-leetcode-dlia-podgotovki-k-texniceskomu-sobesedovaniiu

-   `1. Метод двух указателей Two Pointers` Сложность O(N) (один проход по эементам массива)
    Условия: Отсортированный массив, создаем первый указатель (left) - начало массива, второй указатель (right) - конец массива. Первый и второй указатели на элементы, преверяем сумму этих элементов. Если сумма больше сдвигаем второй указатель (right). Сумма меньше сдвигаем первый указатель (left). В итоге ищется сумма двух элементов == целевой
    Задача: Two sum

-   `2. Метод скользящего окна Sliding Window`
    Есть массив элементов, окно - это подмассив, взятый из основного. Для улучшения производительности окно - инициализируется и высчитывается итог. Далее заходим в основной цикл, благодаря инициализированному окну у нас уже есть данные для первой итерации, следующая итерация мы изменяем окно (удалить предыдущий элемент, добавить новый элемент)
    Задача: Дан массив, найти в наибольшее среднее арифмитическое в подмассивах размером 5

-   `3. Задача о рюкзаке`
    @1 определить все комбинации
    @2 пройтись по всем комбинациям и выбрать подходящий под условия ответ
    Задача: Есть предметы у них имеется цена и вес, нужно сложить предметы в рюкзак (вместимость = 5). Вам нужно постараться поместить в рюкзак различные комбинации фруктов так, чтобы их общий вес не превышал 5, и имел самую высокую стоимость

-   `4. Метод быстрого и медленного указателя (Алгоритм зайца и черепахи)`
    Алгоритм для решения поиска зациклинностей в связанных циклах:
    Необходимо определить, есть ли в этом списке цикл (очевидно, что цикл в односвязном списке может быть максимум один) и если есть, то напечатать номер первого узла этого цикла в порядке обхода списка.
    Примеры:
    1->2->3->4->5->6->7->null простой связанный список, циклов нет
    1->[2->3->4->2] найден цикл на 2
    [1->2->3->1] найден цикл на 1

-   `5. Интервалы слияния`
    Задача: Дан список интервалов. Объедините все перекрывающиеся интервалы так, чтобы получился список, состоящий только из взаимоисключающих интервалов.
    Интервалы: [[1,4], [2,5], [7,9]]
    Результат: [[1,5], [7,9]]

-   `6. Разворот связного списка на месте`
    Задача: Дан односвязный список. Необходимо развернуть его на месте, то есть без выделения дополнительной памяти.
    Вы перемещаетесь по связному списку и отслеживаете три узла: текущий, предыдущий и следующий. Отслеживая эти узлы, вы сможете развернуть связный список прямо во время обхода. Если говорить более подробно, то вы должны указать текущий узел на предыдущий. Далее следующий узел становится текущим, и процесс продолжается.
    Этот метод имеет пространственную сложнсость O1, и получается, что мы сможет развернуть связный список за один обход. Отсюда, временная сложность этого метода в наихудшем случае составит ON, где N – это количество узлов в связном списке.

-   `7. Поиск дерева в ширину (BFS – Breadth first search)`
    Алгоритм поиска в ширину применяется для обхода и поиска древовидных или графовых структур данных. Сначала исследуются все узлы текущей глубины, а затем мы переходим к узлам на следующем уровне глубины. Алгоритм BFS, как правило, реализуется с помощью очереди.
    С помощью этого подхода можно эффективно решить любую задачу, которая связана с поуровневым обходом дерева. Для отслеживания и рационального обхода всех узлов уровня вам потребуется очередь. Только после того, как вы обойдете один уровень, вы можете перейти к следующему. Это значит, что пространственная сложность алгоритма составит OW, где W – это максимальное количество узлов на каком-либо уровне.
    Алгоритм:
    Начинает с того, что добавлчем узел root (корень) в очередь.
    Продолжнаем до тех пор, пока очередь не станет пустой.
    На каждой итерации сначала подсчитываем количество элементов в очереди (давайте назовем его levelSize). Именно столько узлов у нас будет на текущем уровне.
    Затем удаляем узлы, которые мы посчитали в levelSize, из очереди и добавляем их value (значения) в массив для представления текущего уровня.
    Когда мы удаляем узлы из очереди, мы добавляем в нее оба его потомка.
    Если очередь не опустела, то повторяем шаг 3 для следующего уровня.

-   `7. Поиск дерева в глубину (DFS - Depth first search)`


-   `8. Кумулятивная сумма Prefix sum`
    Паттерн алгоритма Prefix sum (также известен как кумулятивная сумма) используется для эффективного вычисления суммы всех элементов массива до определённого индекса. 5
    Основная идея: предварительно вычислить сумму всех элементов до каждого индекса в массиве, а затем использовать эти вычисленные суммы для быстрого расчёта суммы любого подмассива в массиве. 5

    Алгоритм реализации Prefix sum:

    Создать новый массив той же длины, что и исходный, и инициализировать первый элемент значением первого элемента исходного массива. 5
    Начиная со второго элемента, итерировать по остальному исходному массиву, и для каждого элемента вычислять сумму префикса, добавляя текущий элемент к предыдущей сумме префикса, и хранить это значение в соответствующем элементе нового массива. 5
    Чтобы найти сумму любого подмассива, использовать предварительно вычисленный массив суммы префикса, вычитая сумму префикса начального индекса подмассива из суммы префикса конечного индекса + 1. 5
